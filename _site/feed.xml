<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>Stylish Jekyll Theme</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Browser Timing API's</title>
				<description>&lt;p&gt;I was fortunate enough to be able to attend the Velocity conference in New York and I have to say, I’m pretty pumped about what I’ve learned.  There’s actually so much to share that it’ll take a little time to get through so today I thought I’d start with the timing api’s.&lt;/p&gt;

&lt;h3 id=&quot;what-are-the-timing-apis&quot;&gt;What are the Timing API’s?&lt;/h3&gt;

&lt;p&gt;Long story short, the api’s allow us to measure real web page timing metrics using javascript.  This is awesome because we can report on exactly what kind of experience our users are actually having when they visit our sites.&lt;/p&gt;

&lt;p&gt;There are three separate api’s that are available: Navigation, Resource, and User.  We’ll go over Navigation Timing in this post.&lt;/p&gt;

&lt;h3 id=&quot;navigation-timing&quot;&gt;Navigation Timing&lt;/h3&gt;

&lt;p&gt;Navigation timing is where you should start your performance measurements; it tells us how long our pages take to load.  In fact, it goes into incredible detail about each step the browser is taking to retrieve a web page.  Here’s a quick rundown of the information that the api provides.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;navigationStart&lt;/strong&gt; - This attribute returns the time immediately after the page unload event has finished.  Basically, if there was a previous page loaded in the browser and you navigate to a new one, a page unload event occurrs.  navigationStart returns the time immediately after this event.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unloadEventStart&lt;/strong&gt; - As you leave a web page within a browser, the browser fires an unload event.  The unloadEventStart attribute returns the starting time of the unload event.  You would use this with the next attribute, unloadEventEnd, to measure how long the unload event takes to complete.  This attribute, and it’s sibling, only work if there was a previous document and that document was on the same domain.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unloadEventEnd&lt;/strong&gt; - This is the end time of the unload event.  unloadEventEnd - unloadEventStart = How long the unload event took.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redirectStart&lt;/strong&gt; - If one of your pages redirects to another page on the same domain, this attribute gives us the starting time of the document fetch.  Like the previous two attributes, it works best with it’s sibling…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;redirectEnd&lt;/strong&gt; - There are a lot of Start/End pairs in the api.  redirectEnd - redirectStart = How long it took redirect to another page and receive all the bytes for the new page.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fetchStart&lt;/strong&gt; - This returns the time before the browser issues an HTTP GET and before it checks it’s local cache.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domainLookupStart&lt;/strong&gt; - This one is what you expect it to be, the start time of the browser issuing a DNS lookup for a resource, but there is a bit more to understand.  If your browser has a persistent connection to the server or if the resource is found in the local browser cache, then this attribute will return the same value as fetchStart.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domainLookupEnd&lt;/strong&gt; - Again, this one will either be the end time of looking up the domain or, if the resource is in browser cache, it will return the same value as fetchStart.  There’s also one more interesting piece of info to know, browsers can cache their own DNS records.  So these two attributes, domainLookupStart and domainLookupEnd, can reflect the DNS lookup values from the browser’s cache.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;connectStart&lt;/strong&gt; - After a browser has retrieved the DNS records, it’s very next step is to connect to our web server.  This attribute reflects the starting time of that connection.  If the resource was in the local cache or the browser has a persistent connection, this value is equal to domainLookupEnd.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;connectEnd&lt;/strong&gt; - Hurray we established a connection, here’s how long it took: connectEnd - connectStart.  This attribute is also subject to local cache or persistent connections (so it would equal the same thing as domainLookupEnd).  connectEnd also encompasses the time to establish SSL handshakes.  Finally, if a connection attempt fails before it succeeds, then connectStart and connectEnd will only tell us the time values for the successful connection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;secureConnectionStart&lt;/strong&gt; - Unfortunately, this one is currently optional for the browsers.  If a browser does implement it, this is the time just before the SSL handshake process.  If a browser doesn’t implement this, it is suppossed to return undefined.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;requestStart&lt;/strong&gt; - This one confused me for a bit.  requestStart is the time value of when the browser requests the page.  At first, it sounds a lot like fetchStart, and for the most part these two values are probably going to be really close.  The difference, however, is that fetchStart happens before cache/DNS lookups and before connections.  requestStart represents the start time after all those previous steps have finished and the browser can confidently ask for the resource from the correct place.  Notice that there is no requestEnd attribute.  From the documentation and various W3C chat’s I found, a requestEnd attribute was both difficult to define and implement.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;responseStart&lt;/strong&gt; - This is the time immediately after the browser has received the first byte from the server/cache/local resource.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;responseEnd&lt;/strong&gt; - This is either the time immediately after receiving the last byte from the server/cache/local resource or it’s the time just before the transport connection is closed, whichever comes first.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domLoading&lt;/strong&gt; - This is the time just before the browser sets the “current document readiness” state to “loading”.  Honestly, I had no idea what any of that meant so I looked it up.  Here’s the link &lt;a href=&quot;http://www.w3.org/TR/html5/dom.html#current-document-readiness&quot;&gt;http://www.w3.org/TR/html5/dom.html#current-document-readiness&lt;/a&gt;.  Basically, the document object has &lt;a href=&quot;http://www.w3.org/TR/html5/dom.html#the-document-object&quot;&gt;three states&lt;/a&gt;: loading, interactive, and complete (loading while the DOM is still loading, interactive once the DOM is parsed but we’re still waiting on subresources, and complete is all done).  You can see it by going to your browser’s console and typing document.readyState.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domInteractive&lt;/strong&gt; - If any of my domLoading explanation made sense, then this should be apparent.  This is the time just before the document readiness is set to “interactive”.  It also represents the time after blocking scripts have been executed (inline scripts or src scripts that didn’t use defer or asynch).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domContentLoadedEventStart&lt;/strong&gt; - This is the time right before the DOMContentLoaded event.  It also represents the time after the browser has parsed all the scripts that used the defer attribute and not the async attribute.  (So when do async script run?  As soon as they are downloaded they are run… asynchronously).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domContentLoadedEventEnd&lt;/strong&gt; - This is the time right after the DOMContentLoaded event.  This happens once all scripts that are not part of the load event have completed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;domComplete&lt;/strong&gt; - This is just before the document readiness state is set to complete.  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;loadEventStart&lt;/strong&gt; - This is just before the document’s load event is fired.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;loadEventEnd&lt;/strong&gt; - This is just after the document’s load event.  If the event was not fired or not completed, this is zero.&lt;/p&gt;

&lt;h3 id=&quot;so-what-do-we-do-with-all-this&quot;&gt;So What Do We Do With All This?&lt;/h3&gt;

&lt;p&gt;Measure All The Things!  Literally, just start measuring.  There’s a lot of information at our fingertips and it can be combined in various useful ways.  Here’s an example from a GitHub repo by Alois Reitbauer (a member of the W3C performance group).  You can find the repo here: &lt;a href=&quot;https://github.com/AloisReitbauer/w3cinpractice&quot;&gt;https://github.com/AloisReitbauer/w3cinpractice&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var timing= performance.timing;
var loadTime= (timing.loadEventEnd- timing.navigationStart)/1000;
console.log(&#39;Page took &#39; + loadTime.toFixed(2) + &#39; seconds to load&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That’s just the start.  By recording various combinations of these, we can start to understand real user metrics (RUM) and make our users’ experiences better.&lt;/p&gt;

&lt;p&gt;Happpy Coding.&lt;/p&gt;
</description>
				<pubDate>Wed, 01 Oct 2014 23:28:48 -0400</pubDate>
				<link>/2014/10/01/navigation-timing-and-crp.html</link>
				<guid isPermaLink="true">/2014/10/01/navigation-timing-and-crp.html</guid>
			</item>
		
			<item>
				<title>Blogtopics</title>
				<description>&lt;ul&gt;
  &lt;li&gt;Impact of page speed on business&lt;/li&gt;
  &lt;li&gt;List of tools mentioned in Velocity NY 2014&lt;/li&gt;
  &lt;li&gt;List of talks and slides from Velocity NY 2014&lt;/li&gt;
  &lt;li&gt;Implementing a third party script SLA&lt;/li&gt;
  &lt;li&gt;Waterfalls 101&lt;/li&gt;
  &lt;li&gt;Discovering the performance poverty line&lt;/li&gt;
  &lt;li&gt;Creating a strategy for continual performance improvements and experimentation&lt;/li&gt;
  &lt;li&gt;Why to roll your own webpagetest.org&lt;/li&gt;
  &lt;li&gt;Bucketing your users with performance data&lt;/li&gt;
  &lt;li&gt;Joining a W3C group and contributing&lt;/li&gt;
  &lt;li&gt;The W3C Beacon spec&lt;/li&gt;
  &lt;li&gt;Design and how it affects our api endpoints&lt;/li&gt;
  &lt;li&gt;Measuring performance above the fold&lt;/li&gt;
  &lt;li&gt;Review of the best image type to use&lt;/li&gt;
  &lt;li&gt;All about the browser preloader&lt;/li&gt;
  &lt;li&gt;On Experimentation&lt;/li&gt;
  &lt;li&gt;Monitoring third party scripts&lt;/li&gt;
  &lt;li&gt;A Quick and Easy way to Measure Performance: WebPageTest.org&lt;/li&gt;
  &lt;li&gt;Even the big sites have issues&lt;/li&gt;
  &lt;li&gt;Using Google BigQuery and HttpArchive to Answer Questions&lt;/li&gt;
  &lt;li&gt;Creating a strategy for SPOF and Practicing that strategy&lt;/li&gt;
  &lt;li&gt;Don’t forget the basics&lt;/li&gt;
  &lt;li&gt;Relating performance to value&lt;/li&gt;
  &lt;li&gt;The importance of page speed on user perception&lt;/li&gt;
  &lt;li&gt;Tags&lt;/li&gt;
  &lt;li&gt;The new html parser: pup&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Wed, 01 Oct 2014 22:46:43 -0400</pubDate>
				<link>/2014/10/01/BlogTopics.html</link>
				<guid isPermaLink="true">/2014/10/01/BlogTopics.html</guid>
			</item>
		
			<item>
				<title>Browser Timing API's</title>
				<description>
</description>
				<pubDate>Mon, 22 Sep 2014 22:06:50 -0400</pubDate>
				<link>/2014/09/22/browser-timing-api.html</link>
				<guid isPermaLink="true">/2014/09/22/browser-timing-api.html</guid>
			</item>
		
			<item>
				<title>Waiting for User Input</title>
				<description>&lt;p&gt;I love it when things are crazy simple and this is something I want to remember.&lt;/p&gt;

&lt;p&gt;My current project has a form that can be filtered with user input via a textbox.  Pretty simple AJAX stuff, nothing too fancy.  Another developer outside the team even coded it for us so hurray for freebies.  He even went as far as implementing a pretty simple system to keep the input from overloading the server with search queries.&lt;/p&gt;

&lt;p&gt;The problem is, it wasn’t quite enough.  We noticed that just simply typing two or three characters resulted in a minimum of two queries sent to the server.  That’s nothing too worrying, however, one of my designers was trying to implement animations on the search results to help the user understand that something is happening while they’re typing and multiple searches were killing the animation’s ability to keep up.  This resulted in a “janky” animation.&lt;/p&gt;

&lt;p&gt;We decided to implement this code in order to make the search wait until the user stops typing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var keywait;
$scope.searchChanged = function () {
	clearTimeout(keywait);
	keywait = setTimeout(function () {
		if ($scope.querying) {
			$scope.queryOnReturn = true;
			return;
		}

		getActivities();
	}, 240);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The relevant bits here are the clearTimeout call and the setTimeout call.  The 240 millisecond timeout is completely based on how fast I type.&lt;/p&gt;

&lt;p&gt;Happy Coding.&lt;/p&gt;
</description>
				<pubDate>Mon, 22 Sep 2014 21:54:01 -0400</pubDate>
				<link>/2014/09/22/waiting-for-user-input.html</link>
				<guid isPermaLink="true">/2014/09/22/waiting-for-user-input.html</guid>
			</item>
		
			<item>
				<title>Waiting for User Input</title>
				<description>&lt;p&gt;I love it when things are crazy simple and this is something I want to remember.&lt;/p&gt;

&lt;p&gt;My current project has a form that can be filtered with user input via a textbox.  Pretty simple AJAX stuff, nothing too fancy.  Another developer outside the team even coded it for us so hurray for freebies.  He even went as far as implementing a pretty simple system to keep the input from overloading the server with search queries.&lt;/p&gt;

&lt;p&gt;The problem is, it wasn’t quite enough.  We noticed that just simply typing two or three characters resulted in a minimum of two queries sent to the server.  That’s nothing too worrying, however, one of my designers was trying to implement animations on the search results to help the user understand that something is happening while they’re typing and multiple searches were killing the animation’s ability to keep up.  This resulted in a “janky” animation.&lt;/p&gt;

&lt;p&gt;We decided to implement this code in order to make the search wait until the user stops typing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var keywait;
$scope.searchChanged = function () {
	clearTimeout(keywait);
	keywait = setTimeout(function () {
		if ($scope.querying) {
			$scope.queryOnReturn = true;
			return;
		}

		getActivities();
	}, 240);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The relevant bits here are the clearTimeout call and the setTimeout call.  The 240 millisecond timeout is completely based on how fast I type.&lt;/p&gt;

&lt;p&gt;Happy Coding.&lt;/p&gt;
</description>
				<pubDate>Mon, 22 Sep 2014 00:00:00 -0400</pubDate>
				<link>/2014/09/22/waiting-for-user-input.html</link>
				<guid isPermaLink="true">/2014/09/22/waiting-for-user-input.html</guid>
			</item>
		
			<item>
				<title>Industry Leaders and Learning</title>
				<description>
</description>
				<pubDate>Wed, 17 Sep 2014 11:57:45 -0400</pubDate>
				<link>/2014/09/17/industry-leaders-and-testing.html</link>
				<guid isPermaLink="true">/2014/09/17/industry-leaders-and-testing.html</guid>
			</item>
		
			<item>
				<title>The Critical Rendering Path</title>
				<description>&lt;p&gt;Not too long ago, my development studies took me down the web performance path.  There’s a lot to cover when it comes to web site performance ranging from highly technical to just plain common sense.  In this post, I’m going to focus on what I see as a peformance fundamental once you’ve moved past the &lt;a href=&quot;https://developer.yahoo.com/performance/rules.html&quot;&gt;common sense development&lt;/a&gt;.  Let’s talk about the Critical Rendering Path.&lt;/p&gt;

&lt;h3 id=&quot;what-is-the-critical-rendering-path&quot;&gt;What is the Critical Rendering Path?&lt;/h3&gt;

&lt;p&gt;Most of the time, a developer is concerned with the performance of his code either on the server or in the browser.  We’re mindful of the objects we create, the memory we consume and how quickly our code executes.  This is great stuff, but there’s another opportunity for improvement.  How quickly can the browser fetch, parse and render our website?  How long does it take for something to appear on the screen after the user clicks a link?  This is what the Critical Rendering Path is all about.&lt;/p&gt;

&lt;p&gt;To be thorough, here’s a definition directly &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;from Google&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optimizing for performance is all about understanding what happens in these intermediate steps between receiving the HTML, CSS, and JavaScript bytes and the required processing to turn them into rendered pixels - that’s the critical rendering path.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;the-crp-at-30000ft&quot;&gt;The CRP at 30,000ft&lt;/h3&gt;

&lt;p&gt;The link above is great reading and tells you everything you want to know about the CRP, so I’m not going to repeat those details here.  Instead, here’s my “CRP Elevator Talk”.&lt;/p&gt;

&lt;p&gt;In order to display our website, the browser has to go through a few steps (please read Google’s info on the CRP, these steps are overly simplified)	:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Download the html and start to parse/create the DOM.&lt;/li&gt;
  &lt;li&gt;If there are any specified css files, download and begin to parse/create the CSSOM.&lt;/li&gt;
  &lt;li&gt;Combine the DOM and CSSOM into a Render Tree.&lt;/li&gt;
  &lt;li&gt;Execute Javascript.&lt;/li&gt;
  &lt;li&gt;Render the page.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;what-is-a-blocking-operation&quot;&gt;What is a Blocking Operation?&lt;/h3&gt;

&lt;p&gt;A blocking operation is anything that keeps the browser from being able to render the page to the screen, and in the process outlined above, we have a few render blocking operations.&lt;/p&gt;

&lt;p&gt;First, we can’t display a single thing until we’ve downloaded the html and text.  Obvious but true.&lt;/p&gt;

&lt;p&gt;Second, most browsers treat the CSS as a render blocking operation.  Have you ever seen a site that uses css but for some reason the css isn’t applied?  It’s not pretty, so most browsers will say “Oh, we have css, let’s not show anything until we’ve calculated and applied all the right styles.”&lt;/p&gt;

&lt;p&gt;Third Javascript can block in a few different ways.  The first way Javascript will block is with inline scripts.  As we know, Javascript can edit both the DOM and the CSSOM.  Consider this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;span&amp;gt;Hello World!&amp;lt;/span&amp;gt;
&amp;lt;script&amp;gt;
	var span = document.getElementsByTagName(&#39;span&#39;)[0];
	span.textContent = &#39;Hi!&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will display “Hi!”” in the browser window.  What if we change it to this?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script&amp;gt;
	var span = document.getElementsByTagName(&#39;span&#39;)[0];
	span.textContent = &#39;Hi!&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;span&amp;gt;Hello World!&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we see the words “Hello World”.  What happened?  Well clearly we’ve downloaded the necessary resource, the html file (the DOM is actually created incrementally).  According to the critical rendering path, the next step is to start parsing the html and begin creating the DOM.  So in the “Hello World!” case, the browser processes the html tag, then the head, then the body and then it gets to our poorly placed script tag.  The script looks for a span element in the current DOM that has been constructed so far.  Since the span element hasn’t been processed yet, the script cannot execute properly.  If you check the Chrome dev tool console, you’ll see the script tell you it can’t find it, because the script blocked the browser from parsing and creating all of the DOM.&lt;/p&gt;

&lt;p&gt;It get’s even worse when you consider the CSSOM.  Consider, if we had specified a css file in the head for our simple site.  As the browser began to parse and create the DOM, it would come upon the link tag that specified the css file and start to download the file.  As the css file was downloading the browser would continue parsing the rest of the DOM.  Maybe we also decided to change our inline script to edit the page styles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;mystyle.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;span&amp;gt;Hello World!&amp;lt;/span&amp;gt;
&amp;lt;script&amp;gt;
	var span = document.getElementsByTagName(&#39;span&#39;)[0];
    span.textContent = &#39;Hi!&#39;; // changes the DOM
    span.style.color = &#39;blue&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a good connection, everything here is fine; the “Hi!” is rendered and it’s blue.  A bad connection, however, might notice the page takes a little longer.  In order for the script to be able to edit a style, a CSSOM must exist, but if the css file is still downloading, then the CSSOM hasn’t been created.  In this case, the Javascript engine must wait for the css file to download and for the CSSOM to be created.  Only then, can it execute the blue color change.&lt;/p&gt;

&lt;p&gt;Additionally, there’s another consequence of this style block, the DOM still hasn’t been completed.  Another render block.&lt;/p&gt;

&lt;h3 id=&quot;can-i-see-the-crp-in-action&quot;&gt;Can I see the CRP in Action?&lt;/h3&gt;

&lt;p&gt;Actually, yes we can see the CRP.  The network tab in the Chrome dev tools gives us snapshot of the CRP in action.  Here’s what you do.&lt;/p&gt;

&lt;p&gt;Open Chrome, navigate to your site and open up the dev tools (Win - Ctrl + Shift + I, Mac - Cmd + Option + I).  Click the network tab and then refresh your page.  After the page is done loading, dev tools reports with some very useful info.  First of all, at the bottom of dev tools, notice the DOMContentLoaded value (in seconds).  A very brief explanation of DOMContentLoaded is that the DOM has been completely constructed and no css is blocking Javascript execution.  Side note, this is the point where most third party javascript libraries start their execution.&lt;/p&gt;

&lt;p&gt;Next, within the Network tab, scroll back up to the top and find the network request for the html file; it’s probably the first request.  Note how long it took to make the request and receive the entire file.  Now note the difference between the time it took to get the html file and the DOMContentLoaded event.  This is the time when the CRP is in action.&lt;/p&gt;

&lt;p&gt;Ideally, this time difference is small but if it’s not, there’s room for improvement.&lt;/p&gt;

&lt;h3 id=&quot;crp-applied&quot;&gt;CRP Applied&lt;/h3&gt;

&lt;p&gt;The next natural question is, “How do I optimize the CRP?”.  Well it turns out that the answer is, it depends.&lt;/p&gt;

&lt;p&gt;Our web apps are pretty unique so your site problems aren’t my site problems.  There are, however, a few things we can always check:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Number of resources required for the page to render - minimize the number of css and javascript files that are required for your page.  A lot of CRP time can be spent in network traffic.&lt;/li&gt;
  &lt;li&gt;Eliminate redirects.  Again, the network traffic matters.&lt;/li&gt;
  &lt;li&gt;Inline the above the fold css and critical js.&lt;/li&gt;
  &lt;li&gt;Make sure the javascript on your page is absolutely necessary to render the page.  If it’s not, mark the external javascript file as asynch.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These suggestions are just the tip of the iceberg; more to come.&lt;/p&gt;

&lt;p&gt;Happy Coding.&lt;/p&gt;
</description>
				<pubDate>Mon, 15 Sep 2014 00:00:00 -0400</pubDate>
				<link>/2014/09/15/critical-rendering-path.html</link>
				<guid isPermaLink="true">/2014/09/15/critical-rendering-path.html</guid>
			</item>
		
			<item>
				<title>Angular Error Pages</title>
				<description>
</description>
				<pubDate>Fri, 12 Sep 2014 15:07:46 -0400</pubDate>
				<link>/2014/09/12/angular-error-pages.html</link>
				<guid isPermaLink="true">/2014/09/12/angular-error-pages.html</guid>
			</item>
		
			<item>
				<title>The Critical Rendering Path</title>
				<description>&lt;p&gt;Not too long ago, my development studies took me down the web performance path.  There’s a lot to cover when it comes to web site performance ranging from highly technical to just plain common sense.  In this post, I’m going to focus on what I see as a peformance fundamental once you’ve moved past the &lt;a href=&quot;https://developer.yahoo.com/performance/rules.html&quot;&gt;common sense development&lt;/a&gt;.  Let’s talk about the Critical Rendering Path.&lt;/p&gt;

&lt;h3 id=&quot;what-is-the-critical-rendering-path&quot;&gt;What is the Critical Rendering Path?&lt;/h3&gt;

&lt;p&gt;Most of the time, a developer is concerned with the performance of his code either on the server or in the browser.  We’re mindful of the objects we create, the memory we consume and how quickly our code executes.  This is great stuff, but there’s another opportunity for improvement.  How quickly can the browser fetch, parse and render our website?  How long does it take for something to appear on the screen after the user clicks a link?  This is what the Critical Rendering Path is all about.&lt;/p&gt;

&lt;p&gt;To be thorough, here’s a definition directly &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot;&gt;from Google&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Optimizing for performance is all about understanding what happens in these intermediate steps between receiving the HTML, CSS, and JavaScript bytes and the required processing to turn them into rendered pixels - that’s the critical rendering path.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;the-crp-at-30000ft&quot;&gt;The CRP at 30,000ft&lt;/h3&gt;

&lt;p&gt;The link above is great reading and tells you everything you want to know about the CRP, so I’m not going to repeat those details here.  Instead, here’s my “CRP Elevator Talk”.&lt;/p&gt;

&lt;p&gt;In order to display our website, the browser has to go through a few steps (please read Google’s info on the CRP, these steps are overly simplified)	:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Download the html and start to parse/create the DOM.&lt;/li&gt;
  &lt;li&gt;If there are any specified css files, download and begin to parse/create the CSSOM.&lt;/li&gt;
  &lt;li&gt;Combine the DOM and CSSOM into a Render Tree.&lt;/li&gt;
  &lt;li&gt;Execute Javascript.&lt;/li&gt;
  &lt;li&gt;Render the page.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;what-is-a-blocking-operation&quot;&gt;What is a Blocking Operation?&lt;/h3&gt;

&lt;p&gt;A blocking operation is anything that keeps the browser from being able to render the page to the screen, and in the process outlined above, we have a few render blocking operations.&lt;/p&gt;

&lt;p&gt;First, we can’t display a single thing until we’ve downloaded the html and text.  Obvious but true.&lt;/p&gt;

&lt;p&gt;Second, most browsers treat the CSS as a render blocking operation.  Have you ever seen a site that uses css but for some reason the css isn’t applied?  It’s not pretty, so most browsers will say “Oh, we have css, let’s not show anything until we’ve calculated and applied all the right styles.”&lt;/p&gt;

&lt;p&gt;Third Javascript can block in a few different ways.  The first way Javascript will block is with inline scripts.  As we know, Javascript can edit both the DOM and the CSSOM.  Consider this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;span&amp;gt;Hello World!&amp;lt;/span&amp;gt;
&amp;lt;script&amp;gt;
	var span = document.getElementsByTagName(&#39;span&#39;)[0];
	span.textContent = &#39;Hi!&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code will display “Hi!”” in the browser window.  What if we change it to this?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;script&amp;gt;
	var span = document.getElementsByTagName(&#39;span&#39;)[0];
	span.textContent = &#39;Hi!&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;span&amp;gt;Hello World!&amp;lt;/span&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we see the words “Hello World”.  What happened?  Well clearly we’ve downloaded the necessary resource, the html file (the DOM is actually created incrementally).  According to the critical rendering path, the next step is to start parsing the html and begin creating the DOM.  So in the “Hello World!” case, the browser processes the html tag, then the head, then the body and then it gets to our poorly placed script tag.  The script looks for a span element in the current DOM that has been constructed so far.  Since the span element hasn’t been processed yet, the script cannot execute properly.  If you check the Chrome dev tool console, you’ll see the script tell you it can’t find it, because the script blocked the browser from parsing and creating all of the DOM.&lt;/p&gt;

&lt;p&gt;It get’s even worse when you consider the CSSOM.  Consider, if we had specified a css file in the head for our simple site.  As the browser began to parse and create the DOM, it would come upon the link tag that specified the css file and start to download the file.  As the css file was downloading the browser would continue parsing the rest of the DOM.  Maybe we also decided to change our inline script to edit the page styles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;mystyle.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;span&amp;gt;Hello World!&amp;lt;/span&amp;gt;
&amp;lt;script&amp;gt;
	var span = document.getElementsByTagName(&#39;span&#39;)[0];
    span.textContent = &#39;Hi!&#39;; // changes the DOM
    span.style.color = &#39;blue&#39;;
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On a good connection, everything here is fine; the “Hi!” is rendered and it’s blue.  A bad connection, however, might notice the page takes a little longer.  In order for the script to be able to edit a style, a CSSOM must exist, but if the css file is still downloading, then the CSSOM hasn’t been created.  In this case, the Javascript engine must wait for the css file to download and for the CSSOM to be created.  Only then, can it execute the blue color change.&lt;/p&gt;

&lt;p&gt;Additionally, there’s another consequence of this style block, the DOM still hasn’t been completed.  Another render block.&lt;/p&gt;

&lt;h3 id=&quot;can-i-see-the-crp-in-action&quot;&gt;Can I see the CRP in Action?&lt;/h3&gt;

&lt;p&gt;Actually, yes we can see the CRP.  The network tab in the Chrome dev tools gives us snapshot of the CRP in action.  Here’s what you do.&lt;/p&gt;

&lt;p&gt;Open Chrome, navigate to your site and open up the dev tools (Win - Ctrl + Shift + I, Mac - Cmd + Option + I).  Click the network tab and then refresh your page.  After the page is done loading, dev tools reports with some very useful info.  First of all, at the bottom of dev tools, notice the DOMContentLoaded value (in seconds).  A very brief explanation of DOMContentLoaded is that the DOM has been completely constructed and no css is blocking Javascript execution.  Side note, this is the point where most third party javascript libraries start their execution.&lt;/p&gt;

&lt;p&gt;Next, within the Network tab, scroll back up to the top and find the network request for the html file; it’s probably the first request.  Note how long it took to make the request and receive the entire file.  Now note the difference between the time it took to get the html file and the DOMContentLoaded event.  This is the time when the CRP is in action.&lt;/p&gt;

&lt;p&gt;Ideally, this time difference is small but if it’s not, there’s room for improvement.&lt;/p&gt;

&lt;h3 id=&quot;crp-applied&quot;&gt;CRP Applied&lt;/h3&gt;

&lt;p&gt;The next natural question is, “How do I optimize the CRP?”.  Well it turns out that the answer is, it depends.&lt;/p&gt;

&lt;p&gt;Our web apps are pretty unique so your site problems aren’t my site problems.  There are, however, a few things we can always check:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Number of resources required for the page to render - minimize the number of css and javascript files that are required for your page.  A lot of CRP time can be spent in network traffic.&lt;/li&gt;
  &lt;li&gt;Eliminate redirects.  Again, the network traffic matters.&lt;/li&gt;
  &lt;li&gt;Inline the above the fold css and critical js.&lt;/li&gt;
  &lt;li&gt;Make sure the javascript on your page is absolutely necessary to render the page.  If it’s not, mark the external javascript file as asynch.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These suggestions are just the tip of the iceberg; more to come.&lt;/p&gt;

&lt;p&gt;Happy Coding.&lt;/p&gt;
</description>
				<pubDate>Thu, 11 Sep 2014 19:03:55 -0400</pubDate>
				<link>/2014/09/11/critical-rendering-path.html</link>
				<guid isPermaLink="true">/2014/09/11/critical-rendering-path.html</guid>
			</item>
		
			<item>
				<title>All About Angular Scopes</title>
				<description>
</description>
				<pubDate>Tue, 09 Sep 2014 12:04:39 -0400</pubDate>
				<link>/2014/09/09/all-about-angular-scopes.html</link>
				<guid isPermaLink="true">/2014/09/09/all-about-angular-scopes.html</guid>
			</item>
		
	</channel>
</rss>
